## 17 Threads and Locks 

之前章节的大部分讨论都是只关注这样的代码行为：在单个线程中，一次只有一个语句或表达式会执行,然而jvm可以支持一次多个线程执行。这些线程独立地执行一些代码，这些代码操作位于共享的主内存中的值和对象。线程可以通过增加多个硬件处理器，通过在一个硬件处理器上时间分片，或者通过在多个硬件处理器上进行时间分片，来进行支持。

线程由`Thread`类表示。用户创建一个线程的唯一方式是创建这个类的对象；每个线程都与这样一个对象相关联。当对应`Thread`对象上的`start()`方法被调用时，这个线程开始执行。

尤其是当没有正确同步时，线程的行为可能令人困惑且违反直觉。这一章描述多线程程序的语义；它包括了一些规则，当读取一个会被多个线程更新的共享内存时，所看到的数据值取决于这些规则。因为该规范类似于不同硬件架构的内存模型，所以这些语义被称为Java编程语言内存模型。当不会引起迷惑时，我们简单地用“内存模型”指涉这些规则。

这些语义并不规定一个多线程程序应该如何执行，而是描述了多线程程序被允许的表现行为。任何执行策略只要它只生成被允许的行为，都是可接受的执行策略。

### 17.1 Synchronization

java编程语言提供多个机制用于线程间通讯。其中最基本的方法是同步(synchronization)，它使用监视器(monitors)实现。java中的每个对象都关联一个监视器，一个线程可以对它加锁或解锁。一次只有一个线程可以持有一个监视器上的一把锁。任何尝试锁住那个监视器的其它线程都被阻塞，直到他们可以获取那个监视器上的一把锁。一个线程t可能会锁住某个特定监视器多次；每个解锁操作都会反转加锁操作的效果。

`synchronized`语句会计算到一个对象的引用；它然后尝试执行在那个对象的监视器上的锁操作并且直到锁动作成功完成才会继续执行。在锁动作执行后，`synchronized`语句体才被执行。如果语句体的执行一旦完成(要么正常地要么突然地),一个解锁动作会自动在同一个监视器上执行。

当`synchronized`方法被调用时，它自动执行一个锁动作；它的函数体直到锁动作成功完成才会执行。如果这个方法是一个实例方法，它会锁住自身对应的类实例所关联的监视器(即，在方法体被执行期间被称作`this`的对象)。如果方法是`static`的，那么它锁住与某个`Class`对象关联的监视器，这个类对象就是代表方法自身被定义所在的类。同样地，如果语句体的执行一旦完成(要么正常地要么突然地),一个解锁动作会自动在同一个监视器上执行。

java编程语言既不阻止也不需要死锁条件的检测。直接或间接地持有在多个对象上的锁的程序，应该使用常规技术来避免死锁，创建更高级的加锁原语(primitives)避免死锁，如果必要的话。

其他机制，例如读写`volatile`变量以及` java.util.concurrent`包中类的使用，提供了其他同步方法。

### 17.2 Wait Sets and Notification

每个对象，除了有一个关联的监视器，还有一个关联的等待集合( wait set).等待集合是由线程组成的集合。

当对象第一次被创建时，它的等待集合是空的。从等待集合中添加或移除线程的基本动作是自动的(也就是不用采取刻意的动作)。等待集合只能通过方法`Object.wait`,` Object.notify`和`Object.notifyAll`进行操纵。

等待集合的操纵也可以被线程的中断状态所影响，或者被处理中断的`Thread`类的方法所影响。另外，`Thread`类用于睡眠(例如sleep)或者加入(例如join)其他线程的方法，也有一些来源于等待和通知动作的属性。

#### 17.2.1 Wait

一旦对象的 `wait()`方法, 或带时间参数形式的` wait(long millisecs)` 以及` wait(long millisecs, int nanosecs)`方法被调用时，等待动作才会发生。

> 传递0作为` wait(long millisecs)`参数，或者传递两个0作为`wait(long millisecs, int nanosecs)`参数进行的函数调用，等价于`wait()`的调用

如果“wait“调用没有抛出`InterruptedException`异常，那么线程正常从等待状态返回。

让线程t是在对象m上执行“等待”方法的线程，然后让n成为线程t在m上加锁动作的次数，并且这n个加锁动作没有相对应的解锁动作。下面其中一个动作会发生：

- 如果n是0(即线程t并不拥有m上的锁)，那么抛出`IllegalMonitorStateException`异常。

- 如果这是一个带时间参数的“wait”调用，参数`nanosecs`不是`0-999999`范围，或`millisecs`是负数，那么抛出`IllegalArgumentException`异常。

- 如果线程被中断(interrupted)，那么抛出`InterruptedException`，并且t的中断状态被设置为false。

- 否则，以下序列依次发生：

  1. 线程t被添加到对象m的等待集合中，然后在m上执行n次解锁动作。

  2. 接着，线程不会执行任何之后的指令，直到它从m的等待集合中被移除。线程可以由于以下动作的发生，被从等待集合中移除，然后它稍后某个时间恢复执行： 

     - m上执行`notify`函数，且t是m的等待集合中被选中移除的线程。

     - m上执行`notifyAll`函数。

     - t上执行`interrupt`函数。

     - 有时间限制的等待会产生内部动作，这个动作会把t从m的等待集合中移除。这是从等待动作开始至少经历了`millisecs`毫秒加上`nanosecs`纳秒时间后，才会发生。

     - 实现决定的内部动作。尽管不鼓励，但允许实现执行“伪唤醒”(spurious wake-ups),即不需要任何指令，线程就从等待集合中被移除从而能够恢复执行。

       > 注意，这个条件(provision)使得java编程的最佳实践是在循环中使用`wait`，这样的循环通常是线程等待一些逻辑条件成立才会终止。

     每个线程必须决定从等待集合中移除线程的事件的发生顺序。这个顺序不必与其他顺序(orderings)一致，但这些线程的行为必须满足就好像事件是以那个顺序发生的。

     例如，如果线程t在m的等待集合中，且t的中断和m上的通知都发生了(例如，t先被中断，它的中断状态被置为true，随后其他线程在m上调用了某个“notify”方法)，那么在这些事件上必须有一个顺序。如果中断被认为先发生，那么t最终通过抛出`InterruptedException`异常从`wait`中返回，并且在m的等待集合中的其他某些线程(如果在发生通知时存在的话)必须接收到这个通知。如果通知被认为先发生，那么t最终会正常从`wait`中返回，它的中断仍旧被悬挂着。

  3. 线程执行m上的n个锁动作。
  
  4. 如果线程t在步骤2中由于中断被从m的等待集合中移除，那么t的中断状态被设置为false，并且`wait`抛出`InterruptedException`异常。

#### 17.2.2 Notification